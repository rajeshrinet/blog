{
  
    
        "post0": {
            "title": "Active scalar field theory",
            "content": "In this blog, an active scalar field theory with mass and momentum conservation has been used to rationalize recent experimental phenomena in nonequilibrium statistical physics. . Splitting active droplets . Microphase separation (phase separation arrested to a length-scale) is often observed in suspensions of spherical active particles. In such suspensions, the scalar concentration is the only order parameter, when there is no orientational order in the bulk. We show that such microphase separations can be achieved by extending theories of passive binary mixtures (for example, phase separation of oil droplets in passive binary oil-water mixtures). In thermal equilibrium systems, phase separation is a thermodynamic process where a uniformly mixed state can lower its free energy by dividing into phases. Ostwald ripening (small droplets disappear and bigger droplets grow) drives thermal equilibrium systems to full phase separation. In this blog, we show that by coupling the scalar density to fluid flow, the negative mechanical tension of an active suspension creates, via a self-shearing instability, a steady-state life cycle of droplet growth interrupted by division whose scaling behavior we predict. . . The starting point in this theory is the diffusive dynamics of a conserved scalar field $ phi( boldsymbol{r},t)$ in a momentum-conserving fluid of velocity $ boldsymbol{v}( boldsymbol{r},t)$: $ dot{ phi}+ boldsymbol{ nabla} cdot boldsymbol{J}+ boldsymbol{v} cdot boldsymbol{ nabla} phi=0. $ Here, $ boldsymbol{J}$ is the current density of $ phi$, which obeys $ boldsymbol{J}=-M boldsymbol{ nabla} frac{ delta mathcal{F}}{ delta phi} + sqrt{2DM} boldsymbol{ Lambda}, $ where $M$ is a mobility, $ boldsymbol{ Lambda}$ is a zero-mean, unit-variance Gaussian white noise, and $D$ is a noise temperature, while $ mathcal{F}$ is the Landau-Ginzburg free energy functional: $ mathcal{F}[ phi]= int left( frac{a}{2} phi^{2}+ frac{b}{4} phi^{4}+ frac{ kappa}{2}( boldsymbol{ nabla} phi)^{2} right)d boldsymbol{r}. $ This free energy functional admits bulk phase separation for $a&lt;0$, with $b, kappa&gt;0$ for stability [Chaikin and Lubensky(2000)]. . The fluid will be set into motion if the interfaces are not flat. The fluid flow, in the limit of low Reynolds number, is obtained from the solution of the Stokes equation: $ boldsymbol{ nabla} cdot boldsymbol{ sigma}=- boldsymbol{f}$ with $ boldsymbol{f}= boldsymbol{ nabla} cdot( boldsymbol{ Sigma}^{E}+ boldsymbol{ Sigma}^{A})$. Here $ boldsymbol{ sigma}=-p boldsymbol{I}+ eta( boldsymbol{ nabla} boldsymbol{v}+( boldsymbol{ nabla} boldsymbol{v})^{T})$ is the Cauchy fluid stress, $ eta$ is viscosity, $ boldsymbol{I}$ is the identity tensor, and $p$ is the pressure field which contains all isotropic terms and ensures incompressibility $( nabla cdot boldsymbol{v}=0)$. The deviatoric stresses in the bulk are due to gradients of the field $ phi$. Their explicit forms are: $ boldsymbol{ Sigma}^{E}=- kappa boldsymbol{S}$ and $ boldsymbol{ Sigma}^{A}=-( tilde{ kappa}- kappa) boldsymbol{S}$, with $ boldsymbol{S}=( boldsymbol{ nabla} phi)( boldsymbol{ nabla} phi)- tfrac{1}{d}| boldsymbol{ nabla} phi|^{2} boldsymbol{I}$ in $d$-dimensions. . In the absence of $ boldsymbol{ Sigma}^{A}$, the above scalar field theory with mass and momentum conservation is called model H. With the addition of the active stress $ boldsymbol{ Sigma}^{A}$, which does not belong to any free energy, we have obtained $active$ Model H. By construction, active model H does not respect time-reversal symmetry. The interfacial tension, without activity, $ gamma_0= sqrt{-8 kappa a^{3}/9b^{2}}$, is modified to $ gamma_{v}= tilde{ kappa} gamma_0/{ kappa}$. A self-shearing instability is obtained for active extensile stress ($ gamma_v &lt;0$) due to stretching of the interface from the resulting fluid flow (see below). . . This instability interrupts the growth of droplets by splitting them. The extensile active stress has the effect of reversing the sign of the effective tension which arrests the growth. This is balanced by Ostwald ripening: small droplets evaporate while large ones grow until they in turn become unstable. The result is a dynamical steady state maintained by the self-shearing instability. We show that the typical length scale at steady state is proportional to the $1/ sqrt{ tilde{ kappa}}$. When the diffusive tension is also negative, this is replaced by an arrested regime (mechanistically distinct, but with similar scaling) where division of small droplets is prevented by reverse Ostwald ripening. . Reference: Rajesh Singh and Michael E. Cates. Phys. Rev. Lett. 123, 148005 (2019) . . Self-propelling active droplets . . In this work, we present a model of self-propulsion in active droplets, such as cells, by extending the above theory to two scalar fields. The two scalar fields, in the case of a cell, represent the cytoplasm and a contractile cortex. An active stress couples the two scalar fields. The self-propulsion results from the activity when rotational symmetry is spontaneously broken. We find, both analytically and numerically, that the swimming speed does not depend on the radius of the droplet, while it varies linearly with the activity parameter and with the droplet area fraction. . I have also developed, PyGL, a numerical library for statistical field theory in Python. The library has been specifically designed to study field theories without time-reversal symmetry. The library constructs differentiation matrices using finite-difference and spectral methods. To study the role of momentum conservation, the library also allows computing fluid flow from the solution of the Stokes equation. . Reference: Rajesh Singh, Elsen Tjhung, and Michael E. Cates. Phys. Rev. Research 2, 032024(R) (2020) .",
            "url": "https://rajeshrinet.github.io/blog/markdown/2020/08/01/active-droplets.html",
            "relUrl": "/markdown/2020/08/01/active-droplets.html",
            "date": " • Aug 1, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Phoresis and Stokesian hydrodynamics",
            "content": "About . . In this blog, I describe a theory for studying phoretic and hydrodynamic interactions of colloidal particles. The main focus is to understand these long-ranged interactions for a new class of colloids, called active particles, which are distinguished by their ability to produce flow, and thus motion, in the absence of external forces or torques. Active particles can create flow - even when stationary - due to large surface gradients from local nonequilibrium processes. These nonequilibrium processes may be due to the motion of cilia, as in microorganisms (Brennen &amp; Winet, 1977) or osmotic flows of various kinds in response to spontaneously generated gradients of phoretic fields (Ebbens &amp; Howse, 2010) at the colloidal particle. The latter, often called autophoresis, is a generalisation of well-known phoretic phenomena including, inter alia, electrophoresis (electric field), diffusiophoresis (chemical field) and thermophoresis (temperature field) that occur in response to externally imposed gradients of phoretic fields (Anderson, 1989). . Hydrodynamic and phoretic interactions between active particles in a viscous fluid are central to the understanding of their collective dynamics. Under experimentally relevant conditions, the motion of the fluid is governed by the Stokes equation and that of the phoretic field, if one is present, by the Laplace equation. The “activity” appears in these equations as boundary conditions on the particle surfaces that prescribe the slip velocity in the Stokes equation and flux of the phoretic field in the Laplace equation. The slip is a mechanism to drive fluid flow in absence of any external forces and torques. . . We model an active particle as a spherical colloidal particle with surface slip. Thus, the theory is applicable to both active and driven particles. The slip velocity and the phoretic flux are related by a linear constitutive law that can be derived from a detailed analysis of the boundary layer physics (Anderson, 1989). The Stokes and Laplace equations are coupled by this linear constitutive law only at the particle boundaries. The linearity of the governing equations and the coupling boundary conditions allows for a formally exact solution of the problem of determining the force per unit area on the particle surfaces. This formally exact solution can be approximated to any desired degree of accuracy by a truncated series expansion in a complete basis of functions on the particle boundaries. This, in turn, leads to an efficient and accurate numerical method for computing hydrodynamic and phoretic interactions between active particles. We solve these equations simultaneously - using a grid-free method, combining the integral representation of Laplace and Stokes equations, spectral expansion, and Galerkin discretization - to compute phoretic and hydrodynamic interactions between spheres with slip boundary conditions on their surfaces. Details are available in Singh and Adhikari JPC 2018 and Singh, Adhikari and Cates JCP 2019 . The above formalism has been implemented in a numerical library, PyStokes. PyStokes is a numerical library for phoresis and Stokesian hydrodynamics in Python. The resulting methodology has been applied to study various experimental phenomena of recent interest in active and driven matter. In what follows, a selected list of applications is presented. . . Controlled optofluidic crystallization of colloids tethered at interfaces . . Reference: A Caciagli, R Singh, D Joshi, R Adhikari, and E Eiser, Physical Review Letters 125 (6), 068001 (2020) . The interplay between laser light, trapped particles, and fluid flow can produce counterintuitive effects in optical tweezing. Here we uncover an attractive, long-ranged, non-equilibrium force field centered on an optically trapped particle near a water-oil interface, produced by local heating and mediated by global fluid flow. This causes surrounding untrapped colloids, tethered to the interface but allowed to diffusely freely along it, to crystallize around the force center. In this configuration, the non-equilibrium force is the gradient of a potential, of strength proportional to the local heating, which, surprisingly, allows for an effective equilibrium description. Our results open unexplored routes to optofluidic manipulation and assembly of colloidal particles. . . See also this synopsis: Small Spheres Freeze When Hot . . Periodic orbits of active particles . Reference: A Bolitho, R Singh, R Adhikari, Physical Review Letters 124 (8), 088003 (2020) . . Our work shows that the oscillatory dynamics of a pair of active particles near a boundary, best exemplified by the fascinating dance of the green algae Volvox, can be understood in terms of Hamiltonian mechanics, even though the system does not conserve energy. At the heart of this dance, which is a limit cycle of a dynamical system, is a Hamiltonian, damped by gravitational torque and driven by fluid flow reflected off the boundary. For small oscillations, this Hamiltonian is identical to that of a pendulum and, like a metronome, sets the beat of the dance. For large oscillations, the beat can be evaluated with the same mathematics as for a pendulum, and when damping and driving are taken into account, agrees very well with experiment. This establishes without doubt that the enigmatic Volvox dance, rather than being an evolutionarily selected biological phenomenon, is a physical phenomenon that can be understood fully in terms of the familiar concepts of mechanics. Our study highlights the significance of fluid flows and their distortion by boundaries in active matter and shows that the applicability of Hamiltonian mechanics extends beyond its intended domain of energy-conserving systems to time-irreversible, dissipative, active systems. . . Crystallization at a plane no-slip surface . Reference: R Singh, R Adhikari, Physical Review Letters 117, 228002 (2016) . . It is well-known that crystallization of colloids approximating hard spheres is due, paradoxically, to the higher entropy of the ordered crystalline state compared to that of the disordered liquid state. Out of equilibrium, no such general principle is available to rationalize crystallization. Here, we identify a new non-equilibrium mechanism, associated with entropy production rather than entropy gain, which drives crystallization of active colloids near plane walls. This is a new mechanism of spontaneous symmetry breaking, with no analogue in equilibrium. The properties of the non-equilibrium crystal, consequently, show remarkable exceptions: strong dissipation suppresses propagating phonon-modes and turns them diffusive, yet, activity enhances the elastic moduli of the crystal. An active crystal, then, has reduced phase fluctuations and is less susceptible to the destruction of long-ranged order, even though it is two-dimensional. The investigation of topological phase transitions in these systems presents, therefore, exciting avenues for future research. There is an excellent qualitative and quantitative match of our results with two recent experiments. . Kinetics of crystallization . . Attractive monopolar flow of active particles near a plane surface . . Self-assembly of hexagonal cluster of active particles . . . Flow-induced phase separation is controlled by boundary conditions . Reference: S Thutupalli, D Geyer, R Singh, R Adhikari, H Stone Proceedings of the National Academy of Sciences 115, 5403 (2018) . Active colloids - microorganisms, synthetic microswimmers, and self-propelling droplets - are known to self-organize into ordered structures at fluid-solid boundaries. Their mutual entrainment in the attractive component of the flow has been postulated as a possible mechanism underlying this phenomenon. In this work, we describe this fluid-induced phase separation by combining experiments, theory, and numerical simulations, and demonstrate its control by changing the hydrodynamic boundary conditions. We show that, for flow in Hele-Shaw cells, metastable lines or stable traveling bands of colloids can be obtained by varying the cell height, while for flow bounded by a plane, dynamic crystallites are formed. At a plane no-slip wall, these crystallites are characterized by a continuous out-of-plane flux of particles that circulate and re-enter at the crystallite edges, thereby stabilizing them, while the crystallites are strictly two-dimensional at a plane where the tangential stress vanishes. These results are elucidated by deriving, using the boundary-domain integral formulation of Stokes flow, exact expressions for dissipative, long-ranged, many-body active forces and torques between them in respective boundary conditions. The resulting numerical simulations of motion under the action of the active forces and torques are in excellent agreement with experiments. Our work demonstrates the control of phase separation of active particles by boundary conditions. . Vortex-stabilised crystallites at a plane no-slip surface . . Two-dimensional crystallites at a plane no-shear surface . . Traveling bands in a Hele-Shaw cell . . . . Autophoretic arrest of flow-induced phase separation . Reference: R Singh, R Adhikari, ME Cates, The Journal of Chemical Physics 151, 044901 (2019) . Recent experiments have reported the arrest of phase separation in a suspension of active colloids at a plane wall. Attractive hydrodynamic forces are known to cause the aggregation of active colloids at a plane wall. This flow-induced phase separation, in absence of any other interactions, drives the system to a complete phase separation. Here, we describe the role of chemical interactions in modifying this flow-induced phase separation of active colloids at a plane wall. We derive chemohydrodynamic forces and torques on colloids in the limit of rapid diffusion and slow viscous flow. We find that near a plane wall, these forces can be expressed as a gradient of a non-equilibrium potential. This potential can be varied from being purely repulsive to purely attractive by tuning the chemical activity of the colloids. The arrest of phase separation can then be understood from the emergence of a barrier in the effective potential. . . . Active particles in external potentials . The simplest system in which an interplay of non-uniform external fields, activity and Brownian motion can be studied is an active colloid confined in a three-dimensional harmonic potential. We consider two examples: (a) active particles in a single trap, and (b) active particles in a lattice of harmonic traps (optical lattice). . Non-equilibrium convective rolls of confined active particles in a single harmonic trap . Reference: R Singh, S Ghose, R Adhikari, Journal of Statistical Mechanics: Theory and Experiment 2015 (6), P06017 (2015) . . Dynamics in an optical lattice . Reference: R Singh, R Adhikari, Journal of Physics Communications 2, 025025 (2018) . . Dynamics of 1024 contractile and extensile active colloids in a spherical confinement . Reference: R Singh, R Adhikari, Journal of Physics Communications 2, 025025 (2018) . In this examples we consider apolar particles confined in a sphere. We show that the dynamics is different for contractile and extensile particles respectively. . . . Electrohydrodynamic flows: self-assembly of nanoparticles . Reference: D Sarkar, R Singh, A Som, CK Manju, M Ganayee, R Adhikari, T Pradeep, The Journal of Physical Chemistry C 122, 17777 (2018) . In the work, we consider a suspension of driven particles. Unlike an active colloid, a driven colloid can move only under the effect of external potentials. Here, we study the motion of particles under electrohydrodynamic flow in a rectangular geometry. Electrohydrodynamics is the study of the effects of electrostatic forces on fluid flow. Electrohydrodynamic flows result from the motion of free charges on the surface of a fluid by application of a tangential electric field along with the container (Melcher and Taylor, Annu Rev Fluid Mech 1969). In our case, free charged ions are sprayed using electrospray on the air-liquid interface of a rectangular container with an electrode, which provides a tangential electric field. The spray from the cone deposits charges at the air-liquid interface which is then set into motion by the tangential electric field due to the electrode. Thus, the formation of nanoparticle-nanosheet (NP-NS) is observed at the air-liquid interface. . .",
            "url": "https://rajeshrinet.github.io/blog/markdown/2020/07/19/pystokes.html",
            "relUrl": "/markdown/2020/07/19/pystokes.html",
            "date": " • Jul 19, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Stochastic differential equations",
            "content": "%matplotlib inline import numpy as np import matplotlib.pyplot as plt plt.rcParams.update({&#39;font.size&#39;: 24}) . Consider the stochastic differential equation (SDE) $$ dx_t = sigma dW_t $$ Here $W_t$ is a Wiener process: a continuous stochastic process whose increments $W_t - W_{t&#39;}$ are normally distributed with mean zero and variance $t-t&#39;.$ This represents the stochastic driving of the equation with $ sigma= sqrt{2D}$. The system is said to be driven by a multiplicative noise if $D$ depends on the state of the system. The integration of the above differential equation is not uniquely defined in that case and care must taken in choosing the convention. The stochastic integral $$ int_0^T f(x) circ_{ alpha} dW_t = lim_{N rightarrow infty} sum_{n=0}^{N-1} Delta W_{t_n} $$ Here $t_n = frac{n+ alpha}{N}T$, where $ alpha=0,0.5,1$ typically. A correct convention should be chosen from the experimental data or from an another unambigous model. For example, for overdamped Langevin equation, the choice of $ alpha$ can be made by starting with underdamped Langevin equation and then adiabatically eliminating the fast degree of freedom. . Thus, the SDE can be written as $$ dx_t = ( alpha- alpha&#39;) frac{d sigma}{dt}dt + sigma circ_{ alpha&#39;} dW_t $$ . Here the integration convention is given by $ alpha&#39;$ and there is a noise-induced drift term. . Let us now consider the example of an unbiased random walker, and therefore, there is no multiplicative noise. The SDE is then simply $$ x_{t+1} =x_{t} pm sigma sqrt{ Delta t} $$ . N = 512; t0 = 0 tf = 1000 dt = float(tf - t0) / N ts = np.arange(t0, tf, dt) ys = np.zeros(np.prod(ts.shape)) ss = 1 def sigma(t): return ss def simulate(ys, ys0, sqdt): ys[0] = ys0 for i in range(N-1): ys[i+1] = ys[i] + (1-2*np.random.randint(0, 2))*sqdt ys0 = 50 sqdt = np.sqrt(dt) simulate(ys, ys0, sqdt) plt.plot(ts, ys, color=&quot;#348ABD&quot;); . fig = plt.figure(figsize=(16, 5), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;); Ns = 10000 R = np.zeros(Ns) for i in range(Ns): simulate(ys, ys0, sqdt) R[i] = ys[N-1] plt.hist(R, bins=100, density=1, histtype=&#39;stepfilled&#39;, color=&quot;#348ABD&quot;); plt.title(&#39;Histogram of the displacement from origin, ys0 = 50&#39;); . Reflecting boundary conditiom . N = 1000; t0 = 0 tf = 2000 dt = float(tf - t0) / N ts = np.arange(t0, tf, dt) ys = np.zeros(np.prod(ts.shape)) ss = 1 def sigma(t): return ss wallL, wallR = 0, 100 def simulate(ys, ys0, sqdt): ys[0] = ys0 for i in range(N-1): ys[i+1] = ys[i] + (1-2*np.random.randint(0, 2))*sqdt if ys[i+1] &lt; wallL: ys[i+1] = ys[i] elif ys[i+1] &gt; wallR: ys[i+1] = ys[i] ys0 = 50 sqdt = 1*np.sqrt(dt) simulate(ys, ys0, sqdt) plt.plot(ts, ys, color=&quot;#348ABD&quot;); plt.plot(ts, ts*0+wallL, &#39;g-&#39;) plt.plot(ts, ts*0+wallR, &#39;g-&#39;); . fig = plt.figure(figsize=(16, 5), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;); Ns = 10000 R = np.zeros(Ns) for i in range(Ns): simulate(ys, ys0, sqdt) R[i] = ys[N-1] plt.hist(R, bins=100, density=1, histtype=&#39;stepfilled&#39;, color=&quot;#348ABD&quot;); plt.title(&#39;Histogram of the displacement from origin, ys0 = 50&#39;); . Multiplicative noise . We now consider the case when $ sigma$ is function of position and follow the example in the paper. The SDE to be solved is then $$ x_{t+1} =x_{t} pm sigma(x_t + alpha Delta x) sqrt{ Delta t} $$ The above multiplicative noise can be implemented as $$ x_{t+1} =x_{t} + alpha sigma(x_t) frac{d sigma}{dx} dt pm sigma(x_t) sqrt{ Delta t} $$ . N = 1024; t0 = 0 tf = 4 dt = float(tf - t0) / N ts = np.arange(t0, tf, dt) ys = np.zeros(np.prod(ts.shape)) ss = 1 def sigma(t): return ss def simulate(ys, ys0, sqdt, aa, wallL, wallR): ys[0] = ys0 for i in range(N-1): ys[i+1] = ys[i] + aa*ys[i]*dt + ys[i]*(1-2*np.random.randint(0, 2))*sqdt if ys[i+1] &lt; wallL: ys[i+1] = ys[i] elif ys[i+1] &gt; wallR: ys[i+1] = ys[i] ys0 = 50 aa = 1 wallL, wallR = 0, 100 sqdt = np.sqrt(dt) fig = plt.figure(figsize=(16, 5), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;); plt.rc(&#39;text&#39;, usetex=True) plt.rc(&#39;font&#39;, family=&#39;serif&#39;) sp = fig.add_subplot(1, 2, 1 ); aa = 0 simulate(ys, ys0, sqdt, aa, wallL, wallR) plt.plot(ts, ys, color=&quot;#348ABD&quot;); plt.title(r&#39;$ alpha$ = 0&#39;); sp = fig.add_subplot(1, 2, 2 ); aa = 1 simulate(ys, ys0, sqdt, aa, wallL, wallR) plt.plot(ts, ys, color=&quot;#348ABD&quot;); plt.title(r&#39;$ alpha$ = 1&#39;); . fig = plt.figure(figsize=(16, 5), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;); Ns = 4000; R = np.zeros(Ns) sp = fig.add_subplot(1, 2, 1 ); aa = 0 for i in range(Ns): simulate(ys, ys0, sqdt, aa, wallL, wallR) R[i] = ys[N-1] plt.hist(R, bins=100, histtype=&#39;stepfilled&#39;, color=&quot;#348ABD&quot;); plt.title(r&#39;$ alpha$ = 0&#39;); sp = fig.add_subplot(1, 2, 2 ); aa = 1 for i in range(Ns): simulate(ys, ys0, sqdt, aa, wallL, wallR) R[i] = ys[N-1] plt.hist(R, bins=100, histtype=&#39;stepfilled&#39;, color=&quot;#348ABD&quot;); plt.title(r&#39;$ alpha$ = 1&#39;); . A colloid near a plane wall . In this case the mobility of a colloid is a function of the distance of the colloid from the wall and thus a suitable choice is needed. We use the choice which correspond to adiabtic elimination of the momentum from the full Langevin equation and include the effective drift term (Gardiner, Handbook of Stochastic Methods, 1985). . t0 = 0 tf = 512 N = 10000 dt = float(tf - t0) / N eta = 1.0/6 # viscosity a = 1 # radius def muPerp(h): &quot;&quot;&quot;mobility of a colloid at a height h from a plane wall (perpendicular to wall)&quot;&quot;&quot; return ( 1 - (9.0/8)*(a/h) + 0.5*(a/h)**3) / (6*3.14*eta*a) def driftMuPerp(h): &quot;&quot;&quot;mobility of a colloid at a height h from a plane wall (perpendicular to wall)&quot;&quot;&quot; return ( (9.0/8)*(a/h**2) - 1.5*(a**3/h**4))/(6*3.14*eta*a) def muPar(h): &quot;&quot;&quot;mobility of a colloid at a height h from a plane wall (parallel to wall)&quot;&quot;&quot; return ( 1 - (9.0/16)*(a/h) + (a/(2*h))**3)/(6*3.14*eta*a) def sigma(mu, t): c_sigma = np.sqrt(2*mu) return c_sigma def dW(dt): &quot;&quot;&quot;dW_{n}=W_{n+1} -W_{n}.&quot;&quot;&quot; return np.random.normal(loc=0.0, scale=np.sqrt(dt)) def wallWCA(h): F=0 if h&lt;=1.1: F = 1*1/(h**12) return F return np.random.normal(loc=0.0, scale=np.sqrt(dt)) def simulate(ts, ys): for i in range(1, ts.size): h = ys[i-1] ys[i] = h + (muPerp(h)*wallWCA(h) + driftMuPerp(h))*dt + sigma(muPerp(h), ts[i])*dW(dt) #ys[i] = ys[i-1] + sigma(muPar(h), ts[i])*dW(dt) #declare and initialize ts = np.arange(t0, tf, dt) ys = np.zeros(np.prod(ts.shape)) ys[0] = 25 # height of the colloid from the wall #simulate and plot simulate(ts, ys) plt.plot(ts, ys, color=&quot;#348ABD&quot;); . fig = plt.figure(figsize=(16, 5), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;); ys[0] = 64 # height of the colloid from the wall simulate(ts, ys) sp = fig.add_subplot(1, 2, 1 ); plt.plot(ts, ys, color=&quot;#348ABD&quot;); plt.title(&#39;$h=32$&#39;, fontsize=16); ys[0] = 2 # height of the colloid from the wall simulate(ts, ys) sp = fig.add_subplot(1, 2, 2); plt.plot(ts, ys, color=&quot;#348ABD&quot;); plt.title(&#39;$h=2$&#39;, fontsize=16); . Ornstein-Uhlenbeck Process . import numpy as np import matplotlib.pyplot as plt t0 = 0 tf = 200 N = 1000000 dt = float(tf - t0) / N eta = 1.0/6 # viscosity a = 1 # radius k = 0.01 # stiffness of the trap in plane mu = 1/(6*np.pi*eta*a) def sigma(mu, t): c_sigma = np.sqrt(2*mu) return c_sigma def dW(dt): &quot;&quot;&quot;dW_{n}=W_{n+1} -W_{n}.&quot;&quot;&quot; return np.random.normal(loc=0.0, scale=np.sqrt(dt)) def simulate(ts, ys, h): for i in range(1, ts.size): ys[i] = ys[i-1] - k*mu*ys[i-1] + sigma(mu, ts[i])*dW(dt) #declare and initialize ts = np.arange(t0, tf, dt) ys = np.zeros(np.prod(ts.shape)) ys[0] = 0 z = 25 # height of the colloid from the wall #simulate and plot simulate(ts, ys, z) plt.plot(ts, ys, color=&quot;#A60628&quot;); . plt.hist(ys, bins=64, range=(-1, 1), density=1, histtype=&#39;step&#39;, color=&quot;#348ABD&quot;); plt.title(&#39;Histogram of the displacement from origin&#39;); .",
            "url": "https://rajeshrinet.github.io/blog/jupyter/2020/02/22/FourierSeries.html",
            "relUrl": "/jupyter/2020/02/22/FourierSeries.html",
            "date": " • Feb 22, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Gray-Scott reaction–diffusion equation",
            "content": "The reaction we are modeling is between two generic chemical species u and v such that . $$ u + 2v rightarrow 3v $$and $v$ goes to an inert product. . The overall behavior can be modelled using partial differential equations, named as Gray-Scott reaction-diffusion equation [1], . $$ frac{ partial u}{ partial t} = underbrace{D_u boldsymbol nabla^2 u}_{ substack{ text{diffuse }u text{ for concentration to spread}}} - underbrace{uv^2}_{ text{probability of reaction}} + underbrace{F(1-u)}_{ substack{ text{add more of u } text{with a bound 1}}} $$$$ frac{ partial v}{ partial t} = underbrace{D_v boldsymbol nabla^2 v}_{ substack{ text{diffuse }v text{ for concentration to spread}}} + underbrace{uv^2}_{ text{probability of reaction}} - underbrace{(F+K)v}_{ substack{ text{remove } v text{ from reaction} text{ with a bound 0}}} $$The system shows very rich set of patterns as the parameters for equations are varied. . [1] P. Gray and S. K. Scott, Chemical Oscillations and Instabilities: Non-linear Chemical Kinetics, International Series of Monographs on Chemistry, 1994. . In what follows, we present a numerical implementation of this model. . %matplotlib inline import numpy as np import matplotlib.pyplot as plt from scipy.sparse import spdiags class GrayScott(): &quot;&quot;&quot;Class to solve Gray-Scott Reaction-Diffusion equation&quot;&quot;&quot; def __init__(self, N): self.N = N self.u = np.ones((N, N), dtype=np.float128) self.v = np.zeros((N, N), dtype=np.float128) def laplacian(self): &quot;&quot;&quot;Construct a sparse matrix that applies the 5-point discretization&quot;&quot;&quot; N = self.N e=np.ones(N**2) e2=([1]*(N-1)+[0])*N e3=([0]+[1]*(N-1))*N A=spdiags([-4*e,e2,e3,e,e],[0,-1,1,-N,N],N**2,N**2) return A def initialise(self): &quot;&quot;&quot;Setting up the initial condition&quot;&quot;&quot; N, N2, r = self.N, np.int(self.N/2), 16 self.u += 0.02*np.random.random((N,N)) self.v += 0.02*np.random.random((N,N)) self.u[N2-r:N2+r, N2-r:N2+r] = 0.50 self.v[N2-r:N2+r, N2-r:N2+r] = 0.25 return def integrate(self, Nt, Du, Dv, F, K, L): &quot;&quot;&quot;Integrate the resulting system of equations using the Euler method&quot;&quot;&quot; u = self.u.reshape((N*N)) v = self.v.reshape((N*N)) #evolve in time using Euler method for i in range(int(Nt)): uvv = u*v*v u += (Du*L.dot(u) - uvv + F *(1-u)) v += (Dv*L.dot(v) + uvv - (F+K)*v ) self.u = u self.v = v return def configPlot(self): &quot;&quot;&quot;Plotting business&quot;&quot;&quot; u = self.u v = self.v f = plt.figure(figsize=(25, 10), dpi=400, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;); sp = f.add_subplot(1, 2, 1 ); plt.pcolor(u.reshape((N, N)), cmap=plt.cm.RdBu) plt.axis(&#39;tight&#39;) sp = f.add_subplot(1, 2, 2 ); plt.pcolor(v.reshape((N, N)), cmap=plt.cm.RdBu) plt.axis(&#39;tight&#39;) plt.show() N = 256 ## grid size (change to smaller number for faster simulations) Nt = 3.2e4 ## duraction of simulation . Bacteria . rdSolver = GrayScott(N) L = rdSolver.laplacian() Du, Dv, F, K = 0.14, 0.06, 0.035, 0.065 rdSolver.initialise() rdSolver.integrate(Nt, Du, Dv, F, K, L) rdSolver.configPlot() . Coral patterns . rdSolver = GrayScott(N) L = rdSolver.laplacian() Du, Dv, F, K = 0.16, 0.08, 0.060, 0.062 rdSolver.initialise() rdSolver.integrate(Nt, Du, Dv, F, K, L) rdSolver.configPlot() . Spirals . rdSolver = GrayScott(N) L = rdSolver.laplacian() Du, Dv, F, K = 0.12, 0.08, 0.020, 0.050 rdSolver.initialise() rdSolver.integrate(Nt, Du, Dv, F, K, L) rdSolver.configPlot() . Zebrafish . rdSolver = GrayScott(N) L = rdSolver.laplacian() Du, Dv, F, K = 0.16, 0.08, 0.035, 0.060 rdSolver.initialise() rdSolver.integrate(Nt, Du, Dv, F, K, L) rdSolver.configPlot() .",
            "url": "https://rajeshrinet.github.io/blog/jupyter/2020/02/21/gray-scott.html",
            "relUrl": "/jupyter/2020/02/21/gray-scott.html",
            "date": " • Feb 21, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Fourier methods",
            "content": "The Fourier transform (FT) for a well-behaved functions $f$ is defined as: . $$f(k) = int e^{-ikx} f(x) ~dx$$ . The inverse FT is then . $$f(x) = frac{1}{2 pi} int e^{ikx} f(k) ~dk$$ . Discrete Fourier transforms (DFTs) . If the function is periodic in real space, $f(x+L) = f(x)$, then the Fourier space is discrete with spacing $ frac{2 pi}{L}$. Moreover, if the real space is periodic as well as discrete with the spacing $h$, then the Fourier space is discrete as well as bounded. . $$f(x) = sum e^{ikx} f(k) ~dk~~~~~~ text{where } k = Bigg[ - frac{ pi}{h}, frac{ pi}{h} Bigg];~~ text{with interval} frac{2 pi}{L} $$ . This is very much in line with crystallography with $ [ - frac{ pi}{h}, frac{ pi}{h} ]$ being the first Brillouin zone. So we see that there is a concept of the maximum wavenumber $ k_{max}= frac{ pi}{h} $, we will get back to this later in the notes. Usually in computations we need to find FT of discrete function rather than of a well defined analytic function. Since the real space is discrete and periodic, the Fourier space is also discrete and periodic or bounded. Also, the Fourier space is continuous if the real space is unbounded. If the function is defined at $N$ points in real space and one wants to calculate the function at $N$ points in Fourier space, then DFT is defined as . $$f_k = sum_{n=0}^{N-1} f_n ~ e^{-i frac{2 pi~n~k}{N}}$$ . while the inverse transform of this is . $$f_n = frac1N sum_{n=0}^{N-1} f_k ~ e^{~i frac{2 pi~n~k}{N}}$$ . To calculate each $f_n$ one needs $N$ computations and it has to be done $N$ times, i.e, the algorithm is simply $ mathcal{O}(N^2)$. This can be implemented numerically as a matrix multiplication, $f_k = M cdot f_n$, where $M$ is a $N times N$ matrix. . Fast fourier tranforms (FFTs) . The discussion here is based on the Cooley-Tukey algorithm. FFTs improves on DFTs by exploiting their symmetries. . $$ begin{align} f_k &amp;= sum_{n=0}^{N-1} f_n e^{-i~ frac{2 pi~k~n}{N}} &amp;= sum_{n=0}^{N/2-1} f_{2n} e^{-i~ frac{2 pi~k~2n}{N}} &amp;+ sum_{n=0}^{N/2-1} f_{2n + 1} e^{-i~ frac{2 pi~k~(n+1)}{N}} &amp;= sum_{n=0}^{N/2 - 1} f_{2n} e^{-i~ frac{2 pi k~n}{N/2}} &amp;+ e^{-i frac{2 pi k}{N}} sum_{n=0}^{N/2 - 1} f_{2n + 1} e^{-i~ frac{2 pi~k~n~}{N/2}} &amp;= vdots &amp; vdots end{align}$$We can use the symmetry property, from the definition, $f_{N+k} = f_k$. Notice that, because of the tree structure, there are $ ln_2 N$ stages of the calculation. By applying the method of splitting the computation in two halves recursively, the complexity of the problem becomes $ mathcal{O}(N ln N)$ while the naive algorithm is $ mathcal{O}(N^2)$. Below we will look at a simple implementation of FFT. . import numpy as np import matplotlib.pyplot as plt . def testFFT(x): &#39;&#39;&#39; FFT in 1d &#39;&#39;&#39; N = x.shape[0] if N % 2 &gt; 0: raise Exception(&#39;x must have even size&#39;) elif N &lt;= 16: &#39;&#39;&#39; this is the naive implementation using matrix multiplication&#39;&#39;&#39; n = np.arange(N) k = n.reshape((N, 1)) M = np.exp(-2j * np.pi * k * n / N) return np.dot(M, x) else: M1 = testFFT(x[::2]) M2 = testFFT(x[1::2]) fac = np.exp(-2j*np.pi*np.arange(N)/N) return np.concatenate([M1+fac[:N/2]*M2, M1+fac[N/2:]*M2]) . x = np.random.random(1024) #np.allclose(np.fft.fftn(x), testFFT(x)) . L, N = 64, 128 ll = np.linspace(0, L, N) x, y = np.meshgrid(ll, ll) # Fourier grid. kx = 2 * np.pi / L * np.concatenate((np.arange(0, N/2+1,1),np.arange(-N/2+1, 0, 1))) # k = (2 pi)/L ky = 2 * np.pi / L * np.concatenate((np.arange(0, N/2+1,1),np.arange(-N/2+1, 0, 1))) kx, ky = np.meshgrid(kx, ky) def plotFirst(x, y, sig, n_): sp = f.add_subplot(1, 3, n_ ) plt.pcolormesh(x, y, np.real(sig), cmap=plt.cm.gist_heat_r) plt.axis(&#39;off&#39;); f = plt.figure(figsize=(20, 5), dpi=80); rr = np.sqrt( (x - L/2)*(x - L/2) + (y - L/2)*(y - L/2) ) sig = np.fft.fftn(np.exp(-0.1*rr)) xx = ([-L/4, L/2, -L/2,]) yy = ([-L/8, -L/9, L/2]) for i in range(3): kdotr = kx*xx[i] + ky *yy[i] sig = sig*np.exp(-1j*kdotr) plotFirst(x, y, np.fft.ifftn(sig), i+1) . More examples . Sampling: Aliasing error . We saw that because of the smallest length scale, $h$, in the real space there is a corresponding largest wave-vector, $k_{max}$ in the Fourier space. The error is because of this $k_{max}$ and a signal which has $k&gt;k_{max}$ can not be distinguished on this grid. In the given example, below, we see that if the real space has 10 points that one can not distinguish between $sin(2 pi x/L)$ and $sin(34 pi x/L)$. In general, $sin(k_1 x)$ and $sin(k_2 x)$ can not be distinguished if $k_1 -k_2$ is a multiple of $ frac{2 pi}{h}$. This is a manifestation of the gem called the sampling theorem which is defined, as on wikipedia: . If a function x(t) contains no frequencies higher than B hertz, it is completely determined by giving its ordinates at a series of points spaced 1/(2B) seconds apart. . L, N = 1, 16 x = np.arange(0, L, L/512) xx = np.arange(0, L, L/N) def ff(k, x): return sin(k*x) . f = plt.figure(figsize=(17, 6), dpi=80); pi=np.pi; sin=np.sin; cos=np.cos plt.plot(x, ff(x, 2*pi), color=&quot;#A60628&quot;, linewidth=2); plt.plot(x, ff(x, 34*pi), color=&quot;#348ABD&quot;, linewidth=2); plt.plot(xx, ff(xx, 2*pi), &#39;o&#39;, color=&quot;#020e3e&quot;, markersize=8) plt.xlabel(&#39;x&#39;, fontsize=15); plt.ylabel(&#39;y(x)&#39;, fontsize=15); plt.title(&#39;Aliasing in sampling of $sin(2 pi x/L)$ and $sin(34 pi x/L)$&#39;, fontsize=15); . Differentiation . In this section we will use the in-built FFT modules of numpy and then perform differentiation. Differentiation in Fourier space is trivial, $ mathbf{ nabla}_{ alpha}$ gets replaced by $ik_{ alpha}$. Steps involved are . FFT the function to be differentiated. | multiply by suitable numbers of $ik$ | IFFT on the resulting thing to get the differentiated function in real space. | . def f1(kk, x): return cos(kk*x) . f = plt.figure(figsize=(10, 5), dpi=80); L, N = 1, 32 kk = 2*pi/L x = np.arange(0, N)*(L/N) k = np.concatenate(( np.arange(0, N/2+1,1), np.arange(-N/2+1, 0, 1) ))*(2*pi/L) fk = np.fft.fft(f1(kk, x)) f1_kk = -k*k*fk f1_xx = np.fft.ifft(f1_kk) plt.plot(x, -f1(kk, x)*kk*kk, color=&quot;#348ABD&quot;, label = &#39;analytical&#39;, linewidth=2) plt.plot(x, f1_xx, &#39;o&#39;, color=&quot;#A60628&quot;, label = &#39;numerical&#39;, markersize=6) plt.legend(loc = &#39;best&#39;) plt.xlabel(&#39;x&#39;, fontsize=15) plt.title(&#39;derivatives using FFT&#39;, fontsize=15) plt.xlim([0, max(x)]); . /data/septal/rs2004/software/anaconda/lib/python3.7/site-packages/numpy/core/_asarray.py:85: ComplexWarning: Casting complex values to real discards the imaginary part return array(a, dtype, copy=False, order=order) . There are additional symmetry properties for a real function. Wavenumbers corresponding to $j$ and $N-j$ are same and hence we only need to consider wavenumber till N/2! . f = plt.figure(figsize=(10, 5), dpi=80); L, N = 1, 64 x = np.arange(0, L, L/N) kk = 4*pi/L k = np.arange(0, N/2 + 1)*(2*pi/L) # k[2] = 0 # all the pattern is dead at a particular k mode which coooresponds to the signal!! fk = np.fft.rfft(f1(kk, x)) fk = -k*k*fk fx = np.fft.irfft(fk) plt.plot(x, -kk*kk*f1(kk, x), color=&quot;#348ABD&quot;, label = &#39;analytical&#39;, linewidth=2) plt.plot(x, fx, &#39;o&#39;, color=&quot;#A60628&quot;, label = &#39;numerical&#39;) plt.legend(loc = &#39;best&#39;) plt.xlabel(&#39;x&#39;, fontsize=15) plt.title(&#39;derivatives using FFT&#39;, fontsize=15) plt.xlim([0, max(x)]); .",
            "url": "https://rajeshrinet.github.io/blog/jupyter/2020/02/20/Fourier.html",
            "relUrl": "/jupyter/2020/02/20/Fourier.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "Please visit https://rajeshrinet.github.io/ .",
          "url": "https://rajeshrinet.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rajeshrinet.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}